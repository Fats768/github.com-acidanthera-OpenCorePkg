#!/usr/bin/env python3.10

'''
Update autogenerated source files from yaml database.

Copyright (c) 2019, vit9696
'''

import update_products

import fnmatch
import json
import operator
import os
import unicodedata
import sys
import yaml

def remove_accents(input_str):
  nfkd_form = unicodedata.normalize('NFKD', input_str)
  return u''.join([c for c in nfkd_form if not unicodedata.combining(c)])

def load_db(dbpath):
  '''
  Load yaml database and return in a list.
  '''

  if not os.path.exists(dbpath):
    print(f'Cannot find {dbpath} directory, rerun from AppleModels directory!')
    sys.exit(1)

  db = []

  for root, dirs, files in os.walk(dbpath):
    for file in fnmatch.filter(files, '*.yaml'):
      path = os.path.join(root, file)
      with open(path, 'r') as fh:
        try:
            r = yaml.safe_load(fh)
            if r.get('SystemProductName', None) is None:
                print(f'WARN: Missing SystemProductName in {path}, skipping!')
                continue
            db.append(r)
        except yaml.YAMLError as e:
            print(f'Failed to parse file {path} - {e}')
            sys.exit(1)

  if len(db) == 0:
    print('Empty database!')
    sys.exit(1)

  # Sorting is required for fast lookup.
  return sorted(db, key=operator.itemgetter('SystemProductName'))

def gather_products(db, ptype='AppleModelCode', empty_valid=False, shared_valid=False, fatal=True):
  '''
  Obtain all product codes from the database
  '''
  products = []
  for info in db:
    pp = info.get(ptype, None)
    if pp is None:
      continue
    for p in pp:
      if p == '':
        if not empty_valid:
          print(f"ERROR: {info['SystemProductName']} in contains empty {ptype}, skipping!")
          if fatal: sys.exit(1)
        continue
      if p == '000' or p == '0000':
        print(f"WARN: {info['SystemProductName']} in contains zero {ptype}, skipping!")
        continue
      if p in products:
        if not shared_valid:
          print(f"ERROR: {info['SystemProductName']} shares {ptype} {p} with other model!")
          if fatal: sys.exit(1)
        continue
      products.append(p)
  return products

def validate_products(db, dbpd):
  usedproducts  = gather_products(db)

  # FIXME: Empty is not valid, but we let it be for now.
  gather_products(db, 'AppleBoardCode', True, True, False)

  knownproducts = dbpd
  for product in usedproducts:
    if knownproducts.get(product, None) is None:
      print(f'ERROR: Model {prdocut} is used in DataBase but not present in Products!')
      sys.exit(1)
    if knownproducts[product][update_products.KEY_STATUS] != update_products.STATUS_OK:
      print(f'ERROR: Model {product} is used in DataBase but not valid in Products!')
      sys.exit(1)

  to_add = {}

  for product in knownproducts:
    if knownproducts[product][update_products.KEY_STATUS] != update_products.STATUS_OK:
      continue

    name = knownproducts[product][update_products.KEY_NAME]
    if name.find('Mac') < 0 and name.find('Xserve') < 0:
      continue
    if name.find('M1') >= 0:
      continue
      
    if len(product) > 3 and product not in usedproducts:
      print(f'WARN: Model {product} ({name}) is known but is not used in DataBase!')

      if to_add.get(name, None) is None:
        to_add[name] = []
      to_add[name].append(product)
      continue

  if len(to_add) > 0:
    for sysname in to_add:
      for info in db:
        if sysname in info['Specifications']['SystemReportName']:
          print(f"New AppleModelCode for {info['SystemProductName']}:")
          for model in to_add[sysname]:
            print(f"  - \"{model}\"")

def export_db_macinfolib(db, path, year=0):
  '''
  Export yaml database to MacInfoLib format.
  TODO: use jinja2?
  '''

  with open(path, 'w') as fh:
    fh.write('// DO NOT EDIT! This is an autogenerated file.\n')
    fh.write('#include "MacInfoInternal.h"\n')
    fh.write('CONST MAC_INFO_INTERNAL_ENTRY gMacInfoModels[] = {\n')

    for info in db:
      if max(info['AppleModelYear']) < year:
        continue

      sb_model = info.get('AppleModelId')
      sb_model = f"'{sb_model.lower()}'" if sb_model else 'NULL'

      fh.write(' {\n'
        '  .SystemProductName = "%s",\n'
        '  .BoardProduct = "%s",\n'
        '  .BoardRevision = %s,\n'
        '  .SmcRevision = {%s},\n'
        '  .SmcBranch = {%s},\n'
        '  .SmcPlatform = {%s},\n'
        '  .BIOSVersion = "%s",\n'
        '  .BIOSReleaseDate = "%s",\n'
        '  .SystemVersion = "%s",\n'
        '  .SystemSKUNumber = "%s",\n'
        '  .SystemFamily = "%s",\n'
        '  .BoardVersion = "%s",\n'
        '  .BoardAssetTag = "%s",\n'
        '  .BoardLocationInChassis = "%s",\n'
        '  .SmcGeneration = 0x%X,\n'
        '  .BoardType = 0x%X,\n'
        '  .ChassisType = 0x%X,\n'
        '  .MemoryFormFactor = 0x%X,\n'
        '  .PlatformFeature = %s,\n'
        '  .ChassisAssetTag = "%s",\n'
        '  .FirmwareFeatures = 0x%XULL,\n'
        '  .FirmwareFeaturesMask = 0x%XULL,\n'
        '  .SecureBootModel = %s,\n'
        ' },' % (
          info['SystemProductName'],
          info['BoardProduct'][0] if isinstance(info['BoardProduct'], list) else info['BoardProduct'],
          f"0x{info['BoardRevision']:X}" if 'BoardRevision' in info else 'MAC_INFO_BOARD_REVISION_MISSING',
          ', '.join(map(str, info.get('SmcRevision', [0x00]))),
          ', '.join(map(str, info.get('SmcBranch', [0x00]))),
          ', '.join(map(str, info.get('SmcPlatform', [0x00]))),
          info['BIOSVersion'],
          info['BIOSReleaseDate'],
          info['SystemVersion'],
          info['SystemSKUNumber'],
          info['SystemFamily'],
          info['BoardVersion'],
          info['BoardAssetTag'],
          info['BoardLocationInChassis'],
          info['SmcGeneration'],
          info['BoardType'],
          info['ChassisType'],
          info['MemoryFormFactor'],
          f"0x{info['PlatformFeature']:X}" if 'PlatformFeature' in info else 'MAC_INFO_PLATFORM_FEATURE_MISSING',
          info['ChassisAssetTag'],
          info.get('ExtendedFirmwareFeatures', info.get('FirmwareFeatures', 0)),
          info.get('ExtendedFirmwareFeaturesMask', info.get('FirmwareFeaturesMask', 0)),
          sb_model
        ))

    fh.write('};\n')

    fh.write('CONST UINTN gMacInfoModelCount = ARRAY_SIZE (gMacInfoModels);\n')
    fh.write('CONST UINTN gMacInfoDefaultModel = 0;\n')


def export_db_macserial(db, dbpd, path, year=0):
  '''
  Export yaml database to macserial format.
  TODO: use jinja2?
  '''

  with open(path, 'w') as fh:
    fh.write('#ifndef GENSERIAL_MODELINFO_AUTOGEN_H\n')
    fh.write('#define GENSERIAL_MODELINFO_AUTOGEN_H\n')
    fh.write('// DO NOT EDIT! This is an autogenerated file.\n')
    fh.write('#include "macserial.h"\n')

    fh.write('typedef enum {\n')

    for info in db:
      fh.write(f"  {info['SystemProductName'].replace(',', '_')}, // {info['Specifications']['CPU'][0]}\n")

    fh.write('} AppleModel;\n')
    fh.write(f'#define APPLE_MODEL_MAX {len(db)}\n')

    fh.write('static PLATFORMDATA ApplePlatformData[] = {\n')
    for info in db:
      fh.write(f"  {{ '{info['SystemProductName']}', '{info['SystemSerialNumber']}' }},\n")

    fh.write('};\n')

    fh.write(f"#define APPLE_MODEL_CODE_MAX {max(len(info['AppleModelCode']) for info in db)}\n")
    fh.write('static const char *AppleModelCode[][APPLE_MODEL_CODE_MAX] = {\n')

    for info in db:
      fh.write(f"""  /* {info['SystemProductName']:14} */ {{'{'", "'.join(info['AppleModelCode'])}'}},\n""")

    fh.write('};\n')

    fh.write(f"#define APPLE_BOARD_CODE_MAX {max(len(info['AppleBoardCode']) for info in db)}\n")
    fh.write('static const char *AppleBoardCode[][APPLE_BOARD_CODE_MAX] = {\n')

    for info in db:
      fh.write(f"""  /* {info['SystemProductName']:14} */ {{'{'", "'.join(info['AppleBoardCode'])}'}},\n""")

    fh.write('};\n')

    fh.write(f"#define APPLE_MODEL_YEAR_MAX {max(len(info['AppleModelYear']) for info in db)}\n")
    fh.write('static uint32_t AppleModelYear[][APPLE_MODEL_YEAR_MAX] = {\n')
    for info in db:
      fh.write(f"  /* {info['SystemProductName']:14} */ {{{', '.join(str(year) for year in info['AppleModelYear'])}}},\n")

    fh.write('};\n')

    fh.write('static uint32_t ApplePreferredModelYear[] = {\n')
    for info in db:
      fh.write(f"  /* {info['SystemProductName']:14} */ {info.get('MacserialModelYear', 0)},\n")

    fh.write('};\n')

    fh.write('static APPLE_MODEL_DESC AppleModelDesc[] = {\n')

    models = sorted(dbpd.keys())
    models.sort(key=len)

    for model in models:
      if dbpd[model][update_products.KEY_STATUS] == update_products.STATUS_OK:
        fh.write(f" {{'{model}', '{remove_accents(dbpd[model][update_products.KEY_NAME])}'}},\n")

    fh.write('};\n')

    fh.write('#endif // GENSERIAL_MODELINFO_AUTOGEN_H\n')

def export_mlb_boards(db, boards):
  l = {}
  for info in db:
    if len(info['SystemSerialNumber']) == 12:
      models = [info['BoardProduct']] if not isinstance(info['BoardProduct'], list) else info['BoardProduct']

      for model in models:
          l[model] = 'latest' if info['MaximumOSVersion'] is None else info['MaximumOSVersion'] 

  with open(boards, 'w') as fh:
    json.dump(l, fh, indent=1)

if __name__ == '__main__':
  db   = load_db('DataBase')
  dbpd = update_products.load_products()
  # Run test phase to validate the library
  validate_products(db, dbpd)
  export_db_macinfolib(db, os.devnull)
  export_db_macserial(db, dbpd, os.devnull)
  # Export new models
  export_db_macinfolib(db, '../Library/OcMacInfoLib/AutoGenerated.c')
  export_db_macserial(db, dbpd, '../Utilities/macserial/modelinfo_autogen.h')
  # Export MLB models
  export_mlb_boards(db, '../Utilities/macrecovery/boards.json')
